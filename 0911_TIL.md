# 사용자 수준 스레드 & 커널 수준 스레드

## 스레드 제어 블록(TCB)

- 스레드의 정보를 저장하는 블록
- 프로세스 안에 여러 스레드를 가질 수 있어 PCB는 스레드 제어 블록을 리스트로 가지고 있다.

## 스레드 구현


- **`생성 주체가 누구냐에 따라`** 사용자 수준 스레드와 커널 수준 스레드가 구분된다

### 사용자 수준 스레드 - 다대일 매핑

- 사용자가 스레드 관련 라이브러리를 통해 구현하고 사용하는 스레드
    - 여기서 라이브러리는 스레드의 생성과 종료, 스레드 간의 메시지 전달, 스레드의 스케줄링과 컨텍스트 등의 정보를 보관한다
- 스레드와 관련된 모든 행위를 사용자 영역에서 한다
→ 커널은 사용자 수준 스레드의 존재를 알지 못하고, 스레드 교환에 개입하지 않는다.
→ 커널에서 사용자 영역으로 전환할 필요가 없다
- **`사용자 수준 스레드 N개가 커널 수준 스레드 한 개에 매핑`**되어서 다대일 스레드 매핑이라고 한다
→ 커널이 스레드가 아닌 프로세스를 한 단위로 인식하고 프로세서를 할당한다

- 장점
    - 이식성이 높다
        - 커널에 독립적으로 스케줄링이 가능해 모든 운영체제에 적용할 수 있다.
    - 커널 영역으로 전환하는 오버헤드가 줄어든다
        - 스케줄링이나 동기화를 위해 커널을 호출하지 않는다 → 전부 사용자가 관리
    - 유연한 스케줄링이 가능하다
        - 커널이 아닌 스레드 라이브러리에서 스레드 스케줄링을 제어하므로 응용 프로그램에 맞게 스케줄링 가능하
- 단점
    - 시스템의 동시성을 지원하지 않는다
        - 스레드가 아닌 프로세스 단위로 프로세서를 할당하여 다중 처리 환경을 갖춰도 스레드 단위로 다중 처리를 하지 못한다
        - 하나의 프로세스로부터 할당된 여러 개의 스레드들 중 한 스레드가 대기 상태가 되면 모든 스레드를 실행시킬 수 없다
    - 확장에 제약이 따른다
        - 커널이 한 프로세스에 속한 여러 스레드에 프로세서를 동시에 할당할 수 없어 다중 처리 시스템에서 규모를 확장하기가 어렵다
    - 스레드 간 보호에 커널의 보호 방법을 사용할 수 없어 라이브러리 수준의 보호 방법까지만 사용 가능하다
        - 커널이 스레드 관리에 개입하지 않기 때문이다

### 커널 수준 스레드 - 일대일 매핑


- OS의 커널이 만들고 스레드와 관련된 모든 작업을 커널이 관리하는 스레드이다
→ 사용자 수준 스레드의 한계를 극복하는 방법
- 한 프로세스에서 다수의 스레드가 프로세서를 할당받아 병행으로 수행하고, 스레드 한 개가 대기 상태가 되면 동일한 프로세스에 속한 다른 스레드로 교환이 가능
→ 교환하는 순간도 커널이 개입하기 때문에 사용자 영역에서 커널 영역으로 전환이 필요함
- 사용자 수준 스레드와 커널 수준 스레드가 1:1로 매핑된다
→ 사용자 수준 스레드를 생성하면 이에 대응하는 커널 스레드를 자동으로 생성
- 장점
    - 커널의 관리 지원을 많이 받을 수 있다
    → 커널이 직접 스케줄링하고 실행하기 때문이다
    - 동일한 프로세스에서 할당된 여러 개의 스레드들 중 한 스레드가 대기 상태가 되더라도 다른 스레드들을 실행시킬 수 있다
    → 커널이 각 스레드들을 개별적으로 관리할 수 있기 때문
- 단점
    - 오버헤드가 늘어난다
    - 스케줄링과 동기화를 하려면 사용자 수준 스레드보다 많은 자원이 필요하다

### 혼합형 스레드 - 다대다 매핑


- 사용자 수준 스레드와 커널 수준 스레드를 혼합한 구조
- 사용자 수준 스레드는 커널 수준 스레드와 비슷한 경량 프로세스에 다대다로 매핑되고, 경량 프로세스는 커널 수준 스레드와 일대일로 매핑된다
    - 시스템 호출을 할 때 다른 스레드를 중단하는 다대일 매핑의 사용자 수준 스레드 문제 극복
    - 스레드 수를 제한하는 일대일 매핑의 커널 수준 스레드 문제 극복
    - 다수의 사용자 수준 스레드에 다수의 커널 스레드가 다대다로 매핑된다
- 프로세스 하나에 경량 프로세스가 하나 이상 있고, 경량 프로세스에는 이에 대응하는 커널 스레드가 한 개 있다
    - 경량 프로세스 단위로 자원과 입출력 대기를 하려고 대기하기 때문에 프로세스는 입출력을 완료할 때까지 대기할 필요가 없다
    → 다른 프로세스들은 대기 상태가 아니기 때문이다
    - 어떤 경량 프로세스가 입출력 완료를 기다리더라도 동일한 프로세스에서 다른 경량 프로세스를 실행할 수 있기 때문이다

### 스레드 풀링

- 시스템이 관리하는 스레드의 풀을 응용 프로그램에 제공하여 스레드를 효율적으로 사용할 수 있게 하는 방법
- **`미리 생성된 스레드를 재사용`**하도록 해서 스레드를 생성하는 시간을 줄인다
→ 결과적으로 시스템의 부담을 덜어 줌
- 동시에 생성할 수 있는 **`스레드 수를 제한`**한다
→ 시스템의 자원 소비를 줄여 응용 프로그램의 전체 성능을 일정 수준으로 유지한다

---

[사용자 수준 스레드와 커널 스레드](https://velog.io/@taehee-kim-dev/%EC%82%AC%EC%9A%A9%EC%9E%90-%EC%88%98%EC%A4%80-%EC%8A%A4%EB%A0%88%EB%93%9C-%EC%BB%A4%EB%84%90-%EC%88%98%EC%A4%80-%EC%8A%A4%EB%A0%88%EB%93%9C)

[스레드 정리](https://coding-start.tistory.com/199)
